# 04 - 演进中的架构：服务架构演进史

> **章节概述**：架构并不是被发明出来的，而是持续演进的结果。本章从历史的视角，梳理软件架构发展历程中出现过的名词术语，分析它们的起源、发展、成功与失败的原因。

---

## 一、原始分布式时代（1970s-1980s）

### 历史背景
在20世纪70年代末到80年代初，计算机科学刚经历了从大型机向微型机的转变：
- **硬件局限**：16位寄存器，不足5MHz时钟频率，不超过1MB内存，64KB单段偏移地址
- **代表产品**：Intel 8086处理器（1978年研制，流行于80年代中期）
- **技术驱动**：硬件算力限制促使探索多台计算机协作的分布式方案

### 重要成果
尽管最终目标未完全实现，但这一阶段产生了深远影响的技术基础：

#### 核心技术突破
1. **网络运算架构（NCA）**：惠普公司提出，是远程服务调用的雏形
2. **AFS文件系统**：卡内基·梅隆大学提出，最早的分布式文件系统实现
3. **Kerberos协议**：麻省理工学院提出，服务认证和访问控制的基础协议

#### DCE标准体系
为避免UNIX系统版本战争重演，开放软件基金会制定了**分布式运算环境（DCE）**：
- **DCE/RPC**：远程过程调用规范，现代RPC的共同鼻祖之一
- **DCE/DFS**：分布式文件系统规范
- **服务认证**：基于Kerberos的认证机制
- **UUID**：通用唯一识别符的发明

### UNIX设计哲学的挑战
> **核心理念**："保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。"
> —— Richard P. Gabriel，"Worse is Better"原则

**理想目标**：使分布式环境中的服务调用、资源访问等操作尽可能透明化、简单化，让开发者无需过度关注资源是位于本地还是远程。

### 技术困境与问题
"调用远程方法"与"调用本地方法"看似只有两字之差，但要同时兼顾简单、透明、性能、正确、鲁棒、一致等特点时，复杂度完全不同：

#### 分布式带来的核心问题
- **服务发现**：远程服务在哪里？
- **负载均衡**：有多少个服务实例？
- **容错处理**：网络分区、超时、服务出错如何处理？
- **序列化协议**：参数与返回结果如何表示？
- **传输协议**：信息如何传输？
- **权限管理**：认证、授权如何实现？
- **通信安全**：如何保证网络安全？
- **数据一致性**：如何保证不同机器服务返回相同结果？

#### 性能与理念的冲突
- **性能差距**：远程调用与本地调用存在数量级的速度差异
- **妥协方案**：构造长耗时方法来相对忽略远程调用成本
- **理念矛盾**：构造长耗时方法与用分布式提升性能的初衷相冲突
- **开发复杂度**：开发者必须时刻意识到在编写分布式程序，无法轻易跨越本地与远程界限

### 历史教训与评价

#### IBM院士Kyle Brown的反思
> **核心教训**："某个功能**能够**进行分布式，并不意味着它就**应该**进行分布式，强行追求透明的分布式操作，只会自寻苦果。"

#### 时代局限性分析
将系统拆分到不同机器运行带来的问题成本：
- 服务发现、跟踪、通信、容错、隔离、配置
- 传输、数据一致性、编码复杂度
- **结论**：这些问题的代价远超分布式带来的收益

### 两条技术路径
面对困境，计算机科学面临两个选择：
1. **提升单机处理能力**：避免分布式带来的种种问题
2. **完善分布式解决方案**：找到更好的分布式系统构建方法

#### 历史选择：单体时代的到来
- **摩尔定律的作用**：80年代开始，微型计算机性能每两年翻倍
- **硬件算力快速提升**：使单台或少量计算机即可支撑大型信息系统
- **单体架构成为主流**：在相当长时间内占据绝对主导地位

### 历史意义与展望

#### 对后续发展的影响
1. **技术基础奠定**：RPC、DFS等概念的开创
2. **问题清单建立**：识别出分布式系统的核心挑战
3. **理念的延续**：透明分布式的美好愿景被暂时搁置

#### 历史的回归
> **重要观点**：原始分布式时代提出的"如同本地调用一般简单透明的分布式系统"目标，在30多年后（2016年服务网格时代）重新被开发者拾起。

**历史周期**：
- 分布式将经历一段越来越复杂的发展进程
- 随着分布式架构逐渐成熟完善
- 取代单体成为主流后，透明通信的愿景终将实现

---

## 二、单体系统时代（1980s-2000s）

### 概念澄清与历史地位

#### 名称的后置性
- **历史现象**："单体架构"这个概念是在微服务流行后才"事后追认"形成的
- **统治地位**：历史上出现最早、应用最广、使用人数最多、统治时间最长的架构风格
- **习惯性认知**：在相当长时间里，人们习惯了软件架构就应该是单体这种样子

#### 概念误区的澄清
许多微服务资料中，单体系统常以"反派角色"登场，但这种认知存在偏见：

**隐含定语问题**：这些材料实际讨论的是"**大型的**单体系统"，而非所有单体系统。

**小型系统的单体优势**：
- 易于开发、测试、部署
- 进程内调用，运行效率最高
- 完全不应被贴上"反派"标签

> **重要澄清**：单体系统的不足必须基于以下前提才有讨论价值：
> 1. 软件性能需求超过了单机能力
> 2. 开发人员规模明显超过"2 Pizza Team"范畴

### 单体架构的真实定义

#### Wikipedia定义解读
> **官方定义**："单体意味着自包含。单体应用描述了一种由同一技术平台的不同组件构成的单层软件。"

#### 概念误解分析
- **错误理解**："铁板一块"、"不可拆分"
- **正确含义**："自给自足"（Self-Contained，即"自包含"）
- **重要区分**：单体的问题不在于如何拆分，而在于拆分后的隔离与自治能力

### 单体架构的拆分能力

#### 纵向拆分能力
- **分层架构普及**：现代信息系统普遍采用分层架构（Layered Architecture）
- **适用范围**：无论单体、微服务还是其他架构风格都会进行纵向层次划分
- **数据流转**：外部请求在各层间以不同数据结构流转传递
- **单体优势**：在纵向拆分上毫不逊色，甚至因更容易开发、部署、测试而获得便捷性

#### 横向拆分能力
- **模块支持**：可按技术、功能、职责等维度拆分为各种模块
- **封装形式**：可由多个JAR、WAR、DLL、Assembly等模块构成
- **横向扩展**：支持负载均衡器后部署多个相同副本来分摊流量

### 单体架构的真正缺陷

#### 核心问题：缺乏隔离与自治能力

**隔离能力不足**：
- 所有代码运行在同一进程空间
- 任何代码缺陷都会造成全局性影响
- 内存泄漏、线程爆炸、阻塞、死循环等问题影响整个程序
- 高层次公共资源（端口号、数据库连接池）泄漏影响整台机器乃至集群

**自治能力欠缺**：
- 无法单独停止、更新、升级某一部分代码
- 程序升级需要制定专门的停机更新计划
- 灰度发布、A/B测试相对复杂
- 不存在"停掉半个进程，重启1/4个程序"的合理操作

#### 技术异构困难
- 各模块通常需要使用相同程序语言和编程框架
- 技术栈异构非不可能（如JNI），但通常是迫不得已的选择，并不优雅

### 单体 vs 微服务：利弊权衡

#### 沃尔玛超市的比喻
- **大型企业**：划分仓储部、采购部、安保部等，明确职责边界，支持企业成长规模
- **小卖部**：爸、妈、儿子加小黄狗，划分部门纯粹是给自己找麻烦

#### 规模影响分析
- **小规模时**：单体的同进程部署是优势，节约资源
- **大规模时**：部署成本、技术升级迁移成本变得昂贵
- **扩展限制**：只能通过硬件性能提升（加盖楼层）解决问题，无法让不同部门分开办公

### 微服务取代单体的根本原因

#### 并非传统认知的技术问题
前述的隔离、自治、技术异构等问题都不是根本原因。

#### 核心原因：Phoenix特性的兼容性
> **重要观点**：单体系统很难兼容"Phoenix"（凤凰架构）的特性。

**观念转变的重要性**：
- **单体理念**：希望每个部件、每处代码都尽量可靠，靠不出或少出缺陷构建可靠系统
- **战术与战略**：战术层面再优秀，也很难弥补战略层面的不足
- **规模影响**：系统规模越大，交付可靠单体系统越具挑战性

**架构演进的观念转变**：
- **从**："追求尽量不出错"
- **到**：正视"出错是必然"
- **意义**：这种观念转变是微服务挑战并取代单体架构的底气所在

### 向分布式架构的再次转变

#### 新的分布式理由
为了以下目标，程序再次选择分布式：
- 允许程序出错
- 获得隔离、自治能力
- 实现技术异构

#### 历史的延续
开发分布式程序并不意味着一定要依靠今天的微服务架构，在新旧世纪之交，人们探索过几种服务拆分方法，这些探索导致了**面向服务架构（SOA）**的兴盛期，即"SOA时代"的到来。

---

## 三、SOA时代（2000s-2010s）

### 历史背景：从单体走向分布式的探索

为了对大型单体系统进行拆分，让每个子系统都能独立部署、运行、更新，开发者们尝试了多种方案。

### 三种代表性架构模式

#### 1. 烟囱式架构（Information Silo Architecture）
**概念**：完全不与其他相关信息系统进行互操作或协调工作的设计模式

**特点**：
- 又名信息孤岛（Information Island）
- 实际上没有什么"架构设计"可言
- 使用独立的数据库和服务器实现拆分

**致命缺陷**：
- 企业中不存在完全不发生交互的部门
- 系统的人员、组织、权限等主数据必然有重叠
- "老死不相往来"的系统不符合企业需求

#### 2. 微内核架构（Microkernel Architecture）
**概念**：将公共主数据、服务、资源集中到核心系统，业务系统以插件形式存在

**核心思想**：
- 也称插件式架构（Plug-in Architecture）
- 核心（Kernel/Core System）：公共服务、数据、资源
- 插件模块（Plug-in Modules）：具体业务系统

**适用场景**：
- 桌面应用程序
- Web应用程序
- 平台型应用的功能扩展
- 支持二次开发的软件系统

**局限性**：
- 假设插件模块间互不认识、不可预知
- 插件可访问内核公共资源但不能直接交互
- 企业信息系统和互联网应用往往不满足这一前提

#### 3. 事件驱动架构（Event-Driven Architecture）
**核心机制**：通过事件队列管道（Event Queues）实现子系统通信

**工作原理**：
- 外部消息以事件形式发送至管道
- 各子系统获取感兴趣的事件消息进行处理
- 可为事件新增或修改附加信息
- 可发布新事件到管道队列
- 实现高度解耦但能互动的消息处理

**架构优势**：每个消息处理者都是独立的、高度解耦的

### SOA的正式登场

#### 历史节点与组织演进
- **1994年**：Gartner公司首次提出SOA概念（条件不成熟）
- **2006年**：IBM、Oracle、SAP等成立OSOA联盟，制定推进SOA标准
- **2007年**：OSOA转变为国际标准组织，与OASIS共同成立Open CSA

#### SOA的系统性探索

**"更具体"的体现**：
- 不再是抽象概念，而是可操作的软件设计基础平台
- 有明确的技术标准制定组织Open CSA
- 有清晰的软件设计指导原则

**设计原则**：
- 服务的封装性、自治、松耦合
- 可重用、可组合、无状态

**技术架构体系**：
- **远程调用协议**：SOAP协议族（WSDL、UDDI和WS-*协议）
- **服务通信**：企业服务总线（ESB）实现各子系统通信交互
- **数据访问**：服务数据对象（SDO）
- **服务封装**：服务组件架构（SCA）定义服务形式和运行容器
- **业务编排**：为业务流程管理（BPM）提供基础

**核心优势**：
> "SOA针对分布式服务的主要问题，甚至是针对'软件开发'这件事情本身，都进行了更加系统性、更加具体的探索"

#### SOA的宏大理想："更系统"的目标

**终极目标**：总结出一套自上而下的软件研发方法论

**全面覆盖**：
- 如何挖掘需求
- 如何将需求分解为业务能力
- 如何编排已有服务
- 如何开发测试部署新功能

**关注领域**：不仅关注技术，还关注研发过程中的需求、管理、流程、组织

**工业化愿景**：
> "如果有一天写出符合客户需求的软件会像写八股文一样有迹可循、有法可依，那对软件开发者来说也许是无趣的，但整个社会实施信息化的效率肯定会有大幅的提升"

### SOA的衰落与失败原因

#### 复杂性的恶性循环
- **SOAP协议问题**：过于严格的规范定义带来过度复杂性
- **上层建筑加剧**：ESB、BPM、SCA、SDO等进一步加剧复杂性
- **专业人员依赖**：过于精密的流程需要懂复杂概念的专业人员驾驭

#### 历史的重演：与EJB相同的致命伤
- **阳春白雪**：只能是少数系统的精致奢侈品
- **缺乏普适性**：很难作为广泛普适的软件架构风格推广
- **脱离群众**：尽管有IBM等巨头力挺，仍败于Spring、Hibernate等"草根框架"

> **历史教训**："一旦脱离人民群众，终究会淹没在群众的海洋之中，连信息技术也不曾例外过"

### 历史的反思：距离"透明"越来越远

#### 初心的背离
回顾原始分布式时代Unix DCE的设计主旨：
> "让开发人员不必关心服务是远程还是本地，都能够透明地调用服务或者访问资源"

#### 现实的困境
经过30年技术进步，信息系统历经巨石、烟囱、插件、事件、SOA等架构模式，但：
- 应用受架构复杂度的牵绊越来越大
- 已经距离"透明"二字越来越远
- 是否忘记了当年的初心？

#### 向微服务时代的过渡
> **重要转折**：接下来的微服务时代，似乎正是带着这样的自省式问句而开启的。

---

## 四、微服务时代（2010s至今）

### 概念的历史演进

#### 早期阶段（2005-2012）
- **2005年**：Peter Rodgers博士首次提出"Micro-Web-Service"概念
- **初始定义**：专注于单一职责的、语言无关的、细粒度Web服务
- **历史地位**：作为SOA的轻量化补救方案被提出
- **发展状态**：近十年时间里未受到太多追捧

#### 转折期（2012）
**关键事件**：James Lewis在33rd Degree Conference的演讲《Microservices - Java, the Unix Way》

**重要转变**：
- 提到单一服务职责、康威定律、自动扩展、领域驱动设计
- **只字未提SOA**，号召重拾Unix设计哲学
- 微服务开始脱离SOA附庸，成为独立架构风格

> **历史意义**：仿佛与"初心与自省"遥相呼应，微服务迫不及待要成为SOA的革命者

#### 正式确立（2014）
**里程碑文献**：Martin Fowler与James Lewis合写《Microservices: A Definition of This New Architectural Term》

**现代定义**：
> "微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。"

### 微服务的九个核心特征

#### 1. 围绕业务能力构建（Organized around Business Capability）
**康威定律的重要性**：
- 有怎样结构、规模、能力的团队，产生对应的产品
- 这是必然的演化结果，不是偶然巧合
- 跨团队协作成本高昂，高效团队会自然改进
- 最终团队与产品拥有一致的结构

#### 2. 分散治理（Decentralized Governance）
**核心理念**："谁家孩子谁来管"

**权责统一**：
- 开发团队直接对服务运行质量负责
- 有不受外界干预地掌控服务各方面的权力
- 可选择与其他服务异构的技术实现

**实践中的灵活性**：
- 大多数公司会有统一的主流语言和技术栈
- 微服务不反对"统一"，但强调必要时有选择"不统一"的权利
- 例如：Node.js不适合报表页面，AI训练应该选择Python

#### 3. 通过服务来实现独立自治的组件（Componentization via Services）
**服务 vs 类库**：
- **类库**：编译期静态链接，本地调用
- **服务**：进程外组件，远程调用
- **代价与收益**：远程服务有更高调用成本，但这是获得隔离与自治能力的必要代价

#### 4. 产品化思维（Products not Projects）
**思维转变**：
- **避免**：把软件研发视作完成某种功能
- **应该**：视作持续改进、提升的过程

**全生命周期责任**：
- 团队为软件产品整个生命周期负责
- 开发者应知道软件如何开发、运作、用户反馈、售后支持
- 在微服务下，要求每个人都具有产品化思维是可行的

#### 5. 数据去中心化（Decentralized Data Management）
**核心原则**：数据应该按领域分散管理、更新、维护、存储

**中心化存储的问题**：
- 虽然更容易避免一致性问题
- 但同一数据实体在不同服务视角下抽象形态不同
- 例如：书店中的书本
  - 销售领域关注价格
  - 仓储领域关注库存数量
  - 展示领域关注介绍信息

**权衡选择**：
> "尽管在分布式中处理一致性问题相当困难，很多时候都没法使用传统事务处理来保证，但两害相权取其轻，有一些必要的代价仍是值得付出的"

#### 6. 强终端弱管道（Smart Endpoint and Dumb Pipe）
**直接反对SOA**：几乎是指名道姓地反对SOAP和ESB的复杂通信机制

**SOA的复杂性问题**：
- ESB处理消息编码加工、业务规则转换
- BPM集中编排企业业务服务
- SOAP有几十个WS-*协议族处理事务、一致性、认证授权

**微服务的解决方案**：
- 如果服务需要额外通信能力，在服务自己的Endpoint上解决
- 而不是在通信管道上一揽子处理
- 提倡类似经典UNIX过滤器的简单直接通信方式
- RESTful风格通信更适合微服务

#### 7. 容错性设计（Design for Failure）
**观念转变**：
- **不再**：虚幻地追求服务永远稳定
- **接受**：服务总会出错的现实

**技术要求**：
- 自动机制进行快速故障检测
- 持续出错时进行隔离
- 服务恢复时重新联通
- 断路器等设施是必须的支撑点，不是可选组件

**核心价值**：
> "可靠系统完全可能由会出错的服务组成，这是微服务最大的价值所在，也是'凤凰架构'的含义"

#### 8. 演进式设计（Evolutionary Design）
**核心理念**：承认服务会被报废淘汰

**设计哲学**：
- 设计良好的服务应该是能够报废的
- 而不是期望得到长存永生
- 不可更改、无可替代的服务是系统设计脆弱的表现
- 微服务追求的独立、自治是反对这种脆弱性的表现

#### 9. 基础设施自动化（Infrastructure Automation）
**技术驱动**：CI/CD的长足发展显著减少了构建、发布、运维的复杂性

**必要性**：
- 微服务下运维对象比单体架构有数量级增长
- 使用微服务的团队更依赖基础设施自动化
- 人工很难支撑成百上千乃至成万级别的服务

### 微服务与SOA的明确分界

#### 历史的断裂
**Martin Fowler的表态**：
> "由于与SOA具有一致的表现形式，这让微服务的支持者更加迫切地拒绝再被打上SOA的标签...无论如何，SOA与微服务都是两种不同的东西，正因如此，使用一个别的名称来简明地定义这种架构风格就显得更有必要。"

**重要意义**：微服务不再是SOA的变体或衍生品，而是独立、丰满的架构风格

### 微服务时代的双刃剑

#### 自由带来的选择困难
**技术选择的爆炸**：
- **远程调用**：RMI、Thrift、Dubbo、gRPC、Motan2、Finagle、brpc、Arvo、JSON-RPC、REST等
- **服务发现**：Eureka、Consul、Nacos、ZooKeeper、Etcd、CoreDNS等
- **其他领域**：同样是八仙过海，各显神通的局面

#### 对不同角色的影响

**对普通开发者友善**：
- 简单服务不必面临分布式中所有问题
- 无需背上SOA百宝袋般沉重的技术包袱
- 需要什么解决什么，熟悉什么用什么
- Spring Cloud等全家桶进一步屏蔽复杂性

**对架构师满满恶意**：
- 架构能力要求提升到史无前例的程度
- 技术架构者的第一职责是做决策权衡
- 如果知识面不足以覆盖决策内容，将陷入选择困难症

### 时代特征与未来展望

#### 微服务时代的矛盾
> "微服务时代充满着自由的气息，微服务时代充斥着迷茫的选择"

#### 对未来的期待
> "软件架构不会止步于自由，微服务仍不是架构探索终点，如果有下一个时代，笔者希望是信息系统能同时拥有微服务的自由权利，围绕业务能力构建自己的服务而不受技术规范管束，但同时又不必以承担自行解决分布式的问题的责任为代价。管他什么利弊权衡！小孩子才做选择题，成年人全部都要！"

---

## 五、后微服务时代（Cloud Native）

### 时代背景：从软件到软硬一体

#### 问题的重新审视
传统分布式架构问题（注册发现、跟踪治理、负载均衡、传输通信等）从原始分布式时代就存在，但：
> **关键思考**：这些问题一定要由软件系统自己来解决吗？

#### 硬件解决方案的可行性
几乎所有分布式问题都有对应的硬件解决方案：
- **伸缩扩容**：购买新服务器，部署副本实例分担压力
- **负载均衡**：布置负载均衡器，选择恰当均衡算法分流
- **传输安全**：布置TLS传输链路，配置CA证书保证通信安全
- **服务发现**：设置DNS服务器，依赖稳定记录名而非易变IP地址

#### 硬件方案的历史局限
**核心问题**：由硬件构成的基础设施跟不上由软件构成的应用服务的灵活性

**软件的优势**：
- 键盘命令就能拆分不同服务
- 拷贝、启动就能伸缩扩容服务

**硬件的期待**：
> "硬件难道就不可以通过敲键盘就变出相应的应用服务器、负载均衡器、DNS服务器、网络链路这些设施吗？"

### 虚拟化技术的崛起

#### 容器技术的演进
- **早期阶段**：Docker为代表的容器技术主要用于快速启动服务运行环境
- **发展转折**：从单纯的应用封装发展到参与分布式问题解决
- **重要节点**：2017年Kubernetes赢得容器战争胜利

### 2017年：容器战争的终结

#### 历史意义
> "2017年是容器生态发展历史中具有里程碑意义的一年"

#### 关键事件回顾

**CoreOS的投降**：
- RKT容器领导者CoreOS放弃自己的容器管理系统Fleet
- 宣布将所有容器管理功能移至Kubernetes

**Rancher Labs的转向**：
- 放弃内置数年的容器管理系统Cattle
- 提出"All-in-Kubernetes"战略
- Rancher 2.0"反向升级"为完全绑定Kubernetes

**Apache Mesos的妥协**：
- 9月宣布"Kubernetes on Mesos"集成计划
- 由竞争关系转为对Kubernetes提供支持
- 实现与HDFS、Spark、Chronos等框架的集群资源共享

**Docker的认输**：
- Docker公司10月被迫宣布同时支持Swarm与Kubernetes
- 事实上承认了Kubernetes的统治地位

#### 战争结果
持续三四年的"容器编排战争"（Docker Swarm vs Apache Mesos vs Kubernetes）终结，Kubernetes登基加冕。

### Kubernetes vs Spring Cloud对比

#### 基础设施层面 vs 应用层面解决方案

| 功能 | Kubernetes | Spring Cloud |
|------|------------|--------------|
| 弹性伸缩 | Autoscaling | N/A |
| 服务发现 | KubeDNS/CoreDNS | Spring Cloud Eureka |
| 配置中心 | ConfigMap/Secret | Spring Cloud Config |
| 服务网关 | Ingress Controller | Spring Cloud Zuul |
| 负载均衡 | Load Balancer | Spring Cloud Ribbon |
| 服务安全 | RBAC API | Spring Cloud Security |
| 跟踪监控 | Metrics API/Dashboard | Spring Cloud Turbine |
| 降级熔断 | N/A | Spring Cloud Hystrix |

#### 解题思路的根本转变
**传统方式**：在软件代码层面解决分布式问题  
**新思路**：在虚拟化基础设施层面解决分布式问题

### 虚拟化基础设施的优势

#### 软硬界限的模糊
> "当虚拟化的基础设施从单个服务的容器扩展至由多个容器构成的服务集群、通信网络和存储设施时，软件与硬件的界限便已经模糊"

#### 理想愿景的实现
一旦虚拟化硬件能够跟上软件的灵活性：
- **业务与技术分离**：与业务无关的技术性问题从软件层面剥离
- **悄无声息解决**：在硬件基础设施内解决技术问题
- **专注业务逻辑**：软件得以只专注业务，真正"围绕业务能力构建"

#### 历史理想的回归
- **DCE的"透明分布式应用"**成为可能
- **Martin Fowler的"凤凰服务器"**成为可能
- **Chad Fowler的"不可变基础设施"**成为可能

### 云原生时代的特征

#### 软硬一体的合作模式
> "从软件层面独力应对分布式架构所带来的各种问题，发展到应用代码与基础设施软、硬一体，合力应对架构问题的时代"

#### 与微服务时代的关系
- **目标一致性**：与微服务时代追求的目标没有本质改变
- **实现方式变化**：从纯软件方案转向软硬结合方案
- **命名选择**：相比"云原生"，更愿意称为"后微服务时代"

### Kubernetes的局限性

#### 功能完整性问题
> **重要发现**："仅从功能上看，单纯的Kubernetes反而不如之前的Spring Cloud方案"

#### 边界问题的挑战
**问题本质**：有些问题处于应用系统与基础设施的边缘，在基础设施层面很难精细化处理

**典型例子**：服务熔断的粒度问题
- 微服务A调用微服务B的两个服务：B₁（正常）和B₂（持续500错）
- **基础设施层面**：只能按容器管理，粒度相对粗旷
- **两难选择**：
  - 切断A到B的网络通路→影响B₁正常调用
  - 不切断网络通路→持续受B₂错误影响

#### 类似问题的普遍性
**涉及领域**：服务监控、认证、授权、安全、负载均衡等都面临细化管理需求  
**根本原因**：基础设施只能到容器层面，对单个远程服务难以有效管控

### 服务网格：第二次进化

#### 边车代理模式（Sidecar Proxy）的引入
**解决思路**：引入"服务网格"（Service Mesh）的边车代理模式

**边车概念**：指带垮斗的三轮摩托，这里指系统自动在服务容器中注入通信代理服务器

#### 工作机制
**流量劫持**：
- 类似网络安全里的中间人攻击方式
- 在应用毫无感知情况下悄然接管所有对外通信
- 代理相当于那个"挎斗"

**双平面通信**：
- **数据平面通信**：实现正常的服务间通信
- **控制平面通信**：接收来自控制器的指令
- **功能实现**：根据控制平面配置对数据平面通信进行分析处理

#### 实现效果
**技术优势**：
- 不需要在应用层面加入额外处理代码
- 提供几乎不亚于程序代码的精细管理能力
- 实现熔断、认证、度量、监控、负载均衡等附加功能

**定位模糊但效果明确**：
> "很难从概念上判定清楚一个与应用系统运行于同一资源容器之内的代理服务到底应该算软件还是算基础设施，但它对应用是透明的，不需要改动任何软件代码就可以实现服务治理，这便足够了"

### 未来展望：最理想的架构形态

#### 技术预测
**基础设施标准化**：
> "未来Kubernetes将会成为服务器端标准的运行环境，如同现在Linux系统"

**通信模式主流化**：
> "服务网格将会成为微服务之间通信交互的主流模式"

#### 功能替代
**服务网格的作用**：
- 把技术问题隔离于程序代码之外
- 取代Spring Cloud全家桶中大部分组件功能
- 让微服务只需要考虑业务本身的逻辑

#### 终极理想
> **Smart Endpoints的真正实现**：这才是最理想的Smart Endpoints解决方案

**完美分离**：
- 上帝的归上帝，凯撒的归凯撒
- 业务与技术完全分离
- 远程与本地完全透明

> **时代的结论**："也许这就是最好的时代了吧？"

---

## 六、无服务时代（Serverless）

### 时代背景：云计算的成熟与反思

#### 架构演进的根本驱动力
> **核心观察**："人们研究分布式架构，最初是由于单台机器的性能无法满足系统的运行需要"

#### 分布式的复杂性成本
- **理想状态**：对软件研发而言，不去做分布式无疑是最简单的
- **假设推演**：如果单台服务器性能可以是无限的，架构演进结果会截然不同
- **技术影响**：分布式、容器化、微服务都未必会如期出现

#### 云计算带来的相对无限性能
**历史节点**：云计算落地十年后，相对意义的无限性能已成现实

**技术可行性**：通过云端的算力聚合，单个应用可以获得近似无限的计算资源

### 无服务概念的发展历程

#### 工业界的推进
- **2012年**：Iron.io公司率先提出"无服务"（Serverless）概念
- **2014年**：亚马逊发布Lambda商业化无服务应用
- **发展态势**：后续几年逐步获得开发者认可，成为全球最大无服务运行平台
- **2018年**：中国阿里云、腾讯云等厂商跟进，发布无服务产品

#### 学术界的预言

**第一次预言（2009年）**：
UC Berkeley《Above the Clouds: A Berkeley View of Cloud Computing》
- 预言云计算的价值、演进和普及
- 过去十年里一一得到验证

**第二次预言（2019年）**：
UC Berkeley《Cloud Programming Simplified: A Berkeley View on Serverless Computing》
> **核心预测**："我们预测无服务将会发展成为未来云计算的主要形式"

**学术认可**：无服务是被主流学术界认可的发展方向之一

### 无服务架构的技术组成

#### 核心理念
无服务以"简单"为主要卖点，只涉及两块内容：

#### 1. 后端设施（Backend）
**定义**：数据库、消息队列、日志、存储等支撑业务逻辑运行但本身无业务含义的技术组件

**特征**：
- 运行在云中
- 被称为"后端即服务"（Backend as a Service，BaaS）
- 现成可用，无需采购、版权、选型烦恼

#### 2. 函数（Function）
**定义**：业务逻辑代码，粒度接近程序编码角度的函数

**特征**：
- 运行在云端
- 不必考虑算力问题
- 不必考虑容量规划（技术角度）
- 被称为"函数即服务"（Function as a Service，FaaS）

### 无服务的理想愿景

#### 开发者解放计划
**无需关心的方面**：
- **技术组件**：后端技术组件现成可用
- **部署过程**：完全托管到云端，自动完成
- **算力问题**：有整个数据中心支撑，算力可认为无限
- **运维工作**：维护系统平稳运行是云服务商责任

#### 历史类比
**UC Berkeley的比喻**：
> 把无服务架构下开发者不再关心技术层面细节，类比成当年软件开发从汇编语言踏进高级语言的发展过程

**发展意义**：
- 开发者不必关注寄存器、信号、中断等机器底层细节
- 生产力得到极大解放

### 无服务架构的现实局限

#### 并非普适性架构
> **重要观点**：无服务架构有一些天生特点决定了它现在不是，以后如果没有重大变革的话，估计也很难成为一种普适性的架构模式

#### 适合的应用场景
**特征匹配**：短链接、无状态、适合事件驱动的交互形式
- 不需要交互的离线大规模计算
- Web资讯类网站
- 小程序
- 公共API服务
- 移动应用服务端

#### 不适合的应用场景
**特征不匹配**：业务逻辑复杂、依赖服务端状态、响应速度要求高、需要长连接
- 信息管理系统
- 网络游戏
- 其他具有复杂业务逻辑的应用

#### 技术局限的根本原因

**计费模式制约**：
- 无服务必须按使用量（函数运算时间和占用内存）计费
- 用于控制消耗算力的规模

**技术后果**：
- 函数不会一直以活动状态常驻服务器
- 请求到达才开始运行
- 导致函数不便依赖服务端状态
- 导致冷启动时间问题

**性能问题**：
- 目前冷启动时间：数十到百毫秒级别
- Java等启动性能差的应用：接近秒的级别
- 响应性能不可能太好

### 无服务的未来展望

#### 云计算大势所趋
> **基本判断**："云计算毕竟是大势所趋，今天信息系统建设的概念和观念，在（较长尺度的）明天都是会转变成适应云端的"

#### 发展空间预测
**技术形式**：Serverless+API的设计方式会成为主流软件形式之一  
**应用前景**：届时无服务会有更广阔的应用空间

### 无服务与微服务的关系

#### 并非继承替代关系
> **重要澄清**：强调这点是为了避免有读者从两者的名称与安排的顺序产生"无服务就会比微服务更加先进"的错误想法

#### 不同层次的架构
**路径差异**：
- **微服务架构**：分布式系统这条路当前所能做到的极致
- **无服务架构**："不分布式"的云端系统这条路的起点

#### 融合互补的未来
**架构多样性**：
> "笔者相信软件开发的未来不会只存在某一种'最先进的'架构风格，多种具针对性的架构风格同时并存，是软件产业更有生命力的形态"

**边界模糊化**：
> "笔者同样相信软件开发的未来，多种架构风格将会融合互补，'分布式'与'不分布式'的边界将逐渐模糊，两条路线在云端的数据中心中交汇"

#### 实践中的结合
**当前趋势**：已经能看见使用无服务云函数实现微服务架构的苗头

**层次组合**：
- 无服务作为技术层面的架构
- 微服务视为应用层面的架构
- 组合使用完全合理可行

**实现方式多样化**：
> "以后，无论是通过物理机、虚拟机、容器，抑或是无服务云函数，都会是微服务实现方案的候选项之一"

---

## 七、架构演进的历史总结与未来展望

### 历史教训与反思

#### Martin Fowler的谨慎态度
**2014年的评价**：在《Microservices》结束语中，Martin Fowler与James Lewis对微服务日后能否大范围推广，最多只能持有谨慎的乐观

#### 当前的相似情况
**无服务的现状**：与当年微服务情况十分相近，笔者对无服务日后推广同样持谨慎乐观态度

### 软件开发的根本挑战

#### 决策的困境
> **核心难题**："软件开发的最大挑战就在于只能在不完备的信息下决定当前要处理的问题"

#### 未来的不可预测性
> "时至今日，依然很难预想在架构演进之路的前方，微服务和无服务之后还会出现何种形式的架构风格"

### 图灵的永恒智慧

#### 经典名言的现实意义
> **Alan Turing（1950）**："尽管目光所及之处，只是不远的前方，即使如此，依然可以看到那里有许多值得去完成的工作在等待我们。"

#### 对当前的启示
**现实态度**：接受预测能力的局限性  
**积极精神**：专注于当前可以看到并能够完成的工作  
**持续发展**：相信技术演进的持续性和价值

### 架构演进的整体规律

#### 周期性特征
1. **技术理想**：每个时代都有美好的技术愿景
2. **现实制约**：受当时技术条件和环境限制
3. **妥协方案**：在理想与现实间寻找平衡
4. **技术突破**：新技术为旧理想提供实现可能
5. **历史回归**：优秀理念在合适时机重新兴起

#### 发展的连续性
**技术传承**：每个时代的技术探索都为后续发展奠定基础  
**问题延续**：分布式系统的核心问题贯穿始终  
**解决方案演进**：从应用层→基础设施层→软硬一体→云端融合

#### 未来发展的可能方向
**技术融合**：多种架构风格并行发展、融合互补  
**智能化**：AI技术可能为架构选择和优化带来新的可能  
**边界消除**：分布式与非分布式、本地与远程的界限进一步模糊  
**透明化回归**：最终回到原始分布式时代的透明化理想

> **结语**：架构演进是一个螺旋上升的过程，每一次回归都是在更高层次上对初心的重新实现。
