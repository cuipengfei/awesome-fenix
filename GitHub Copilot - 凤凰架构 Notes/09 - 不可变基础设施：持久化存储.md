# 第九部分：不可变基础设施 - 持久化存储

## 1. 容器存储的核心矛盾

- **容器的无状态性**: 容器镜像是不可变的，任何在容器运行时对文件系统的修改都基于“写入时复制”（Copy-on-Write）策略，存储在临时的、隔离的区域。一旦容器终止，这些改动就会丢失。
- **应用的有状态性**: 现实中的应用（如数据库、日志系统）需要持久化地保存数据，数据生命周期必须独立于容器的生命周期。

为了解决这个矛盾，容器必须引入外部的持久化存储方案。

## 2. Kubernetes 存储体系的演进

Kubernetes 围绕 `Volume` 概念构建了一套复杂的、分层的存储体系，以解耦应用（Pod）与具体的存储实现。

### 阶段一：静态存储分配 (Static Provisioning)

这是早期的存储管理方式，由管理员和用户协作完成。

1.  **`Volume` vs. `PersistentVolume` (PV)**:

    - **普通 `Volume`**: 生命周期与 `Pod` 绑定，用于在 `Pod` 内的多个容器间共享数据，但不是为了持久化。
    - **`PersistentVolume` (PV)**: 是由**管理员**预先准备好的、具体的网络存储资源（如一块 NFS、Ceph 或云厂商的磁盘）。它的生命周期独立于任何 `Pod`。

2.  **`PersistentVolumeClaim` (PVC)**:

    - 是**用户**（开发者）对自己应用所需存储能力的**声明**。PVC 中定义了需要多大空间、需要何种访问模式（如 `ReadWriteOnce`, `ReadOnlyMany`, `ReadWriteMany`）等。

3.  **绑定过程 (Binding)**:
    - 用户创建 `Pod` 和 `PVC`。
    - Kubernetes 控制平面会寻找一个能满足 `PVC` 声明条件的、处于可用状态的 `PV`。
    - 如果找到，就将 `PV` 和 `PVC` 进行一对一绑定。`Pod` 就可以通过挂载 `PVC` 来使用这块存储。
    - 如果找不到，`Pod` 将保持 `Pending` 状态，直到有合适的 `PV` 出现。

- **缺点**: 整个过程需要管理员手动介入，预先创建好足够多的 `PV`。在需要动态扩缩容的大规模集群中，这种方式效率低下，难以自动化。

### 阶段二：动态存储分配 (Dynamic Provisioning)

为了解决静态分配的局限性，Kubernetes 引入了 `StorageClass`，实现了存储的按需自动供给。

1.  **`StorageClass`**:

    - 由**管理员**定义，它描述了存储的“类型”。比如，可以定义一个名为 `fast-ssd` 的 `StorageClass` 指向云服务商的高性能 SSD 存储，再定义一个 `slow-hdd` 指向廉价的磁盘存储。
    - `StorageClass` 的核心是指定一个 **`Provisioner` (资源分配器)**，这个 `Provisioner` 知道如何与后端的存储系统（如 AWS EBS, GCE PD）交互来创建存储卷。

2.  **工作流程**:
    - 用户创建 `PVC` 时，不再是期望匹配一个已存在的 `PV`，而是在 `PVC` 中指定一个 `StorageClass` 的名称。
    - `StorageClass` 接管请求，命令其 `Provisioner` 根据 `PVC` 的要求（如 5GB 容量）去后端存储系统中**动态创建一个新的 `PV`**。
    - 新创建的 `PV` 会自动与该 `PVC` 绑定。
    - `Pod` 成功挂载 `PVC` 并启动。

- **优点**: 实现了完全的自动化。管理员只需维护好 `StorageClass`，无需关心具体的 `PV` 创建。用户也只需通过 `PVC` 声明意图，整个流程对用户透明，是目前推荐的主流方式。

## 3. 容器存储接口 (CSI) 与生态

为了将存储驱动的实现从 Kubernetes 核心代码中解耦出来，社区制定了标准的容器存储接口（CSI）。

### Kubernetes 存储架构三大操作

Kubernetes 将一个存储卷的挂载过程抽象为三个核心动作：

1.  **Provision / Delete**: 准备或移除存储资源（由 **PV 控制器** 触发）。
2.  **Attach / Detach**: 将存储设备附加或分离到指定节点（由 **AD 控制器** 触发）。
3.  **Mount / Unmount**: 将设备挂载或卸载到 `Pod` 内的指定路径（由节点上的 **Volume 管理器 (kubelet)** 触发）。

### 从 `FlexVolume` 到 `CSI`

- **`FlexVolume`**: Kubernetes 早期的私有存储扩展机制，实现简单（就是一个可执行文件），但功能有限（不支持 Provision），部署繁琐，现已冻结。
- **`CSI` (Container Storage Interface)**: 现行的标准接口，是一个开放的、基于 gRPC 的规范。存储厂商只需按照 CSI 规范实现 `Identity`、`Controller` 和 `Node` 三个服务，就能以插件的形式接入任何支持 CSI 的容器编排系统。
  - **CSI Controller**: 通常以 `StatefulSet` 部署，负责 `Provision`、`Attach` 等全局操作。
  - **CSI Node**: 以 `DaemonSet` 部署在每个节点上，负责 `Mount` 等节点级别的操作。

Kubernetes 正在将所有内置的（In-Tree）存储驱动迁移到外部的（Out-of-Tree）CSI 插件，以实现更好的解耦和扩展性。

## 4. 存储类型选型

后端存储系统主要分为三类，选择哪种取决于应用场景。

- **块存储 (Block Storage)**:

  - **特点**: 以固定大小的“块”为单位进行读写，性能最高，延迟最低。具有排他性，通常只能被单个节点以读写模式（RWO）挂载。
  - **例子**: 物理硬盘、AWS EBS。
  - **适用场景**: 需要极致 I/O 性能和低延迟的应用，如大型关系型数据库（Oracle）。

- **文件存储 (File Storage)**:

  - **特点**: 提供了文件、目录、权限等高级抽象，基于 POSIX 接口访问。支持多节点并发读写（RWX），易于共享。
  - **例子**: NFS、AWS EFS。
  - **适用场景**: 大多数通用应用的首选，特别是需要多 `Pod` 共享数据的场景，如 Web 内容、开发环境等。

- **对象存储 (Object Storage)**:
  - **特点**: 将数据和元数据打包成“对象”，通过唯一的 ID 访问。天然分布式，容量巨大，扩展成本极低，但延迟相对较高。
  - **例子**: AWS S3。
  - **适用场景**: 备份、归档、静态资源（图片、视频）托管、大数据分析等。通常通过 HTTP API 访问，而非直接挂载为文件系统。
